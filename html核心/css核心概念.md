# css规则
css规则 = 选择器 + 声明块

## 选择器
1. 元素选择器
2. id选择器
3. 类选择器(常用)；

## css代码书写的位置
1. 内部样式表(书写在style原素中，一般书写在header元素中)。
2. 内联样式表，也叫做元素样式表(写在元素的style属性中)。
3. 外部样式表(将样式书写在独立的css文件中)[推荐]。

元素内部文字尺寸大小
1. px： 像素， 绝对单位，简单的理解为文字的高度占多少个像素。
2. em: 相对单位， 相对与父元素的字体大小。
3. 注意：每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小，如果父元素也没有，继续往上找，如果都没有则直接使用基准字号，即系统设置的字体大小。字体行高还可以使用纯数字，表示相对于当前字体高度的多少倍。


## 选择器

### 简单选择器
1. ID选择器
2. 元素选择器
3. 类选择器
4. 通配符选择器(*)
5. 属性选择器(根据属性名和属性值选中的元素，比如：[href]表示选中所有具有href属性的元素， [href=value]表示选中属性值为value的元素)
还有各种属性选择器的规则，可以到mdn查询。
6. 伪类选择器
    - 选中某些元素的某种状态：
        1. link: 超链接未访问时的状态
        2. visited: 超链接访问过后的状态
        3. hover: 鼠标悬停状态
        4. active: 激活状态，鼠标按下状态
        `如果四种状态都要写出按照上面的顺序书写。`

7. 伪元素选择器(默认是行级元素)

### 选择器的组合
1. 后代元素 -- `空格`
2. 子元素 -- `>`
3. 相邻的兄弟元素 -- `+`
4. 兄弟元素 -- `～`
5. 并列选择器 -- `.` 
6. 分组选择器 -- `,`

### 选择器并列
多个选择器，用逗号分隔。

属性选择器的作用等级 行间样式 > id > class | 属性选择器 > 标签选择器 > 通配符
css权重：进制为255
`!important                      无限`
`行间样式                         1000`
`id                              100`
`class｜属性选择器｜伪类            10`
`元素选择器｜伪元素                 1`
`通配符                           0`
如果权重相等，则书写考后的胜出。

section div ul li a em{

}
注意：假如有上面的样式结构，浏览器是从右往左遍历样式。

### 属性值的计算过程
1. 确定声明值(即作者是否书写该属性的值)
2. 成叠冲突(根据权重值解决样式的冲突，确定样式)
3. 使用继承
4. 使用默认样式
每个元素根据上面的计算过程最终确定每个元素的所有样式。

特殊的两个css取值：
- inherit: 手动(强制)继承，将父元素的值取出应用到该元素。
- initial: 初始值，将该属性设置为默认值。


### 盒模型
盒子的类型：
1. 行盒，display等于inline的元素。(表现形式为在页面中不换行)
2. 块盒，display等于block的元素。(表现形式为在页面中独占一行)
常见的行盒有： span, a, img, video, audio

## 盒模型的应用

### 改变宽高范围
box-sizing（一般我们设置的宽高影响的是内容盒，设置box-sizing可以影响宽高的设置范围）

### 改变背景图的覆盖范围
background-clip(默认情况下背景覆盖边框盒，可以通过background-clip进行修改）

### 溢出处理
overflow(控制内容溢出边框盒后的处理方式)

### 断词规则
word-break(会影响文字在什么位置被截断换行)

### 空白处理
white-spaces

### 行盒的显著特点
1. 盒子沿着内容沿伸
2. 行盒不能设置宽高(因为行盒是根据内容决定宽高，调整行盒的宽高。应该使用字体的大小，行高，字体的类型间接调整)
3. 内边距(水平方向有效，垂直方向仅会影响背景，不会实际占用空间)
4. 边框(水平方向有效，垂直方向仅会影响背景，不会实际占用空间)
5. 外边距(水平方向有效，垂直方向不会实际占用空间)

## 行块盒
一般做分页，比如百度的下边的页面跳转
display: inline-block
1. 不独占一行
2. 盒模型中所有尺寸都有效(宽，高，内边距，边框，外边距)

可替换元素：img, video, audio
注意⚠️:可替换元素类似于行块盒，盒模型中的所有尺寸的设置都有效。

## 常规流
### 常规流布局总体规则： 块盒独占一行，行盒水平依次排列
**块盒**
1. 每个块盒的总宽度必须刚好等于包含块的宽度
    - 宽度的默认值是auto
    - margin的取值也可以是auto，默认值为0
    - auto： 将剩余空间吸收掉
    - width的吸收能力强于margin
    - 若宽度，边框，内边距，外边距计算后仍然有剩余空间，该剩余空间被margin-right全部吸收
    - 在常规流中， 块盒在包含块中居中，可以定宽，然后左右margin设置为auto

2. 每个块盒垂直方向上的auto值
    - height： auto，适应内容的高度
    - margin： auto，表示0

3. 百分比取值
    - padding，宽，margin可以取值为百分比
    - 注意⚠️: 以上所有的百分比都是相对于包含块的宽度。

高度百分比：
1. 如果包含块的高度是取决于子元素的高度，则设置百分比无效
2. 包含块的高度是确定的，不取决于子元素，百分比相对于父元素的高度

两个常规流块盒。上下外边距相邻会进行合并，两个外边距取最大值

## 浮动

### 浮动的基本特点
- left: 左浮动
- right: 右浮动

1. 当一个元素浮动后，该元素必定为块盒(当元素浮动后，该元素的display属性会被设为block)
2. 浮动元素的包含块和常规流一样，为父元素的内容盒。
3. 浮动盒子在包含块中排列时，会避开常规流块盒⚠️
4. 常规流块盒在排列时，无视浮动盒子。⚠️
5. 行盒在排列时会避开浮动盒子。(例如图片文字环绕就可用浮动做)
注意⚠️：如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字，该行盒叫做匿名行盒。

### 盒子尺寸
1. 宽度为auto时，适应内容宽度
2. 高度为auto时，与常规流一致，适应内容的高度
3. margin为auto时，为0
4. 边框，内边距，百分比设置与常规流一致。

### 高度坍塌
高度坍塌的根源：常规流盒子的自动高度在计算是不会考虑浮动盒子的高度
清除浮动，涉及css属性：clear

- 默认值：none
- left：清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
- right：清除右浮动，该元素必须出现在前面所有右浮动盒子的下方
- both: 清除左右浮动，该元素必须出现在前面所有左右浮动盒子的下方

### 定位补充
1. 只有定位元素设置z-index有效
2. z-index可以是负数，如果是负数，则遇到常规流，浮动元素，则会被常规流和浮动元素覆盖
3. 绝对定位，固定定位元素一定是块盒
4. 绝对定位，固定定位元素一定不是浮动元素。
5. 没有外边距合并。

### 块级格式化上下文
- 全称Block Formatting Context, 简称BFC
- 它是一块独立的区域，它规定了在该区域中常规流块盒的布局

### 常规流块盒的布局
1. 常规流块盒在水平方向上必须撑满包含块
2. 常规流块盒在包含块的垂直方向上依次摆放
3. 常规流块盒若外边距无缝相邻，则进行外边距合并
4. 常规流块盒的自动高度和摆放位置无视浮动元素

BFC渲染区域：
这个区域有某个HTML元素创建，以下元素会在其内部创建BFC区域
1. 根元素
2. 浮动和定位元素
3. display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个;
4. overflow的值不为visible。

不同的BFC区域。它们进行渲染时互不干扰
创建BFC的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部
具体规则：
1. 创建BFC的元素，它的自动高度需要计算浮动元素
2. 创建BFC的元素，它的边框和不会与浮动元素重叠
3. 创建BFC的元素，不会和它的子元素进行外边距合并

### 浮动盒子的排列规则
1. 左浮动的盒子向上向左浮动
2. 右浮动的盒子向上向右浮动
3. 浮动盒子的顶边不得高于上一个盒子的顶边
4. 若剩余空间无法放下浮动的盒子，则该盒子乡下移动，直到具备足够的空间能容纳盒子，然后再向左或向右浮动

### 堆叠上下文
堆叠上下文(stack context),它是一块区域，这块区域由某个元素创建，它规定了该区域中的内容在z轴上的排列的先后顺序。

### 创建堆叠上下文的元素
1. html元素
2. 设置了z-index数值的定位元素(非auto)

### 同一个堆叠上下文中元素在z轴上的排列
